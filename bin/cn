#!/usr/bin/env node

/**
 * cn - Coherent Network agent CLI
 * 
 * This is a thin wrapper that routes to the appropriate tool.
 * OCaml source in tools/src/cn/, bundled JS in dist/cn.js
 */

const { execSync, spawn } = require('child_process');
const path = require('path');
const fs = require('fs');

const VERSION = '2.0.7';

// Colors (respects NO_COLOR)
const noColor = process.env.NO_COLOR !== undefined;
const c = {
  reset: noColor ? '' : '\x1b[0m',
  green: noColor ? '' : '\x1b[32m',
  red: noColor ? '' : '\x1b[31m',
  yellow: noColor ? '' : '\x1b[33m',
  cyan: noColor ? '' : '\x1b[36m',
  magenta: noColor ? '' : '\x1b[35m',
  dim: noColor ? '' : '\x1b[2m',
};

const ok = (msg) => console.log(`${c.green}✓ ${msg}${c.reset}`);
const fail = (msg) => console.log(`${c.red}✗ ${msg}${c.reset}`);
const info = (msg) => console.log(`${c.cyan}${msg}${c.reset}`);
const warn = (msg) => console.log(`${c.yellow}⚠ ${msg}${c.reset}`);
const cmd = (msg) => `${c.magenta}${msg}${c.reset}`;

const HELP = `cn - Coherent Network agent CLI

Usage: cn <command> [options]

Commands:
  init [name]         Create new hub
  status              Show hub state
  inbox               Manage inbound messages
    check             List inbound branches (from peers)
    process           Materialize to threads/inbox/
    flush             Detect replies, send back to peers
  outbox              Manage outbound messages
    check             List pending sends (threads/outbox/)
    flush             Push to peers, move to threads/sent/
  sync                Full sync: inbox check/process/flush + outbox flush
  commit [msg]        Stage all changes and commit
  push                Push to origin
  save [msg]          Commit + push (convenience)
  peer                Manage peers
  doctor              Check system health
  update              Update cn to latest version

Aliases:
  i = inbox, s = status, d = doctor

Flags:
  --help, -h          Show help
  --version, -V       Show version

Examples:
  cn init sigma       Create hub named 'sigma'
  cn inbox check      List inbound branches
  cn doctor           Check system health
`;

// Expand aliases
const aliases = { i: 'inbox', o: 'outbox', s: 'status', d: 'doctor', p: 'peer', t: 'thread' };
const expandAlias = (cmd) => aliases[cmd] || cmd;

// Find hub path
function findHubPath() {
  let dir = process.cwd();
  while (dir !== '/') {
    if (fs.existsSync(path.join(dir, '.cn', 'config.json'))) {
      return dir;
    }
    // Also check for cn-* pattern with state/peers.md
    if (fs.existsSync(path.join(dir, 'state', 'peers.md'))) {
      return dir;
    }
    dir = path.dirname(dir);
  }
  return null;
}

// Derive name from path
function deriveName(hubPath) {
  const base = path.basename(hubPath);
  return base.startsWith('cn-') ? base.slice(3) : base;
}

// Append-only action log
function logAction(hubPath, action, details = {}) {
  const logsDir = path.join(hubPath, 'logs');
  if (!fs.existsSync(logsDir)) {
    fs.mkdirSync(logsDir, { recursive: true });
  }
  const entry = {
    ts: new Date().toISOString(),
    action,
    ...details
  };
  fs.appendFileSync(
    path.join(logsDir, 'cn.log'),
    JSON.stringify(entry) + '\n'
  );
}

// Run inbox commands (threads/inbox/ model)
function runInbox(subCmd, hubPath, name) {
  const inboxDir = path.join(hubPath, 'threads', 'inbox');
  const peersPath = path.join(hubPath, 'state', 'peers.md');
  
  // Ensure inbox dir exists
  if (!fs.existsSync(inboxDir)) {
    fs.mkdirSync(inboxDir, { recursive: true });
  }
  
  // Load peers
  let peers = {};
  if (fs.existsSync(peersPath)) {
    const peersContent = fs.readFileSync(peersPath, 'utf8');
    peers = parsePeers(peersContent);
  }
  
  if (subCmd === 'check') {
    // Actor model: check MY repo for inbound branches from peers (peer/*)
    info(`Checking inbox for ${name}...`);
    
    // Fetch my own repo
    try {
      execSync('git fetch origin', { cwd: hubPath, stdio: 'pipe' });
    } catch (err) {
      warn('Failed to fetch origin');
    }
    
    let totalInbound = 0;
    
    for (const [peerName, peer] of Object.entries(peers)) {
      if (peer.kind === 'template') continue; // Skip template repo
      
      try {
        // Find branches from this peer in MY repo (peerName/*)
        const branches = execSync(`git branch -r | grep "origin/${peerName}/" | sed 's/.*origin\\///'`, { 
          cwd: hubPath, 
          encoding: 'utf8',
          stdio: ['pipe', 'pipe', 'pipe']
        }).trim().split('\n').filter(b => b);
        
        if (branches.length > 0) {
          logAction(hubPath, 'inbox.fetch', { from: peerName, branches, count: branches.length });
          warn(`From ${peerName}: ${branches.length} inbound`);
          branches.forEach(b => console.log(`  ← ${b}`));
          totalInbound += branches.length;
        } else {
          console.log(`  ${c.dim}${peerName}: no inbound${c.reset}`);
        }
      } catch (err) {
        // No branches found
        console.log(`  ${c.dim}${peerName}: no inbound${c.reset}`);
      }
    }
    
    if (totalInbound === 0) {
      ok('Inbox clear');
    }
    return;
  }
  
  if (subCmd === 'process') {
    // Actor model: materialize inbound branches from MY repo to threads/inbox/
    info('Processing inbox...');
    let processed = 0;
    
    for (const [peerName, peer] of Object.entries(peers)) {
      if (peer.kind === 'template') continue; // Skip template repo
      
      try {
        // Find branches from this peer in MY repo
        const branches = execSync(`git branch -r | grep "origin/${peerName}/" | sed 's/.*origin\\///'`, { 
          cwd: hubPath, 
          encoding: 'utf8',
          stdio: ['pipe', 'pipe', 'pipe']
        }).trim().split('\n').filter(b => b);
        
        for (const branch of branches) {
          // Get files from this branch
          try {
            const files = execSync(`git diff main...origin/${branch} --name-only 2>/dev/null || git diff master...origin/${branch} --name-only`, {
              cwd: hubPath,
              encoding: 'utf8',
              stdio: ['pipe', 'pipe', 'pipe']
            }).trim().split('\n').filter(f => f.endsWith('.md'));
            
            for (const file of files) {
              // Get file content from branch
              const content = execSync(`git show origin/${branch}:${file}`, {
                cwd: hubPath,
                encoding: 'utf8',
                stdio: ['pipe', 'pipe', 'pipe']
              });
              
              // Write to inbox with metadata
              const inboxFileName = `${peerName}-${path.basename(branch)}.md`;
              const inboxFilePath = path.join(inboxDir, inboxFileName);
              
              // Skip if already materialized
              if (fs.existsSync(inboxFilePath)) {
                continue;
              }
              
              // Add/update frontmatter
              const meta = {
                from: peerName,
                branch: branch,
                file: file,
                received: new Date().toISOString()
              };
              const finalContent = ensureFrontmatter(content, meta);
              fs.writeFileSync(inboxFilePath, finalContent);
              
              logAction(hubPath, 'inbox.materialize', { from: peerName, branch, file, inboxFile: inboxFileName });
              ok(`Materialized: ${inboxFileName}`);
              processed++;
            }
          } catch (err) {
            // Branch might not have files or diff failed
          }
        }
      } catch (err) {
        // No branches found
      }
    }
    
    if (processed === 0) {
      info('No new threads to materialize');
    } else {
      ok(`Processed ${processed} thread(s)`);
    }
    return;
  }
  
  if (subCmd === 'flush') {
    // Scan inbox for agent replies, send back
    info('Scanning inbox for replies...');
    
    const threads = fs.readdirSync(inboxDir)
      .filter(f => f.endsWith('.md'))
      .map(f => {
        const filePath = path.join(inboxDir, f);
        const content = fs.readFileSync(filePath, 'utf8');
        const meta = parseFrontmatter(content);
        return { file: f, path: filePath, content, meta };
      });
    
    let replied = 0;
    for (const t of threads) {
      // Check if agent has replied (look for ## Reply section or reply: true in frontmatter)
      const hasReply = t.meta.reply === 'true' || t.content.includes('\n## Reply\n') || t.content.includes('\n## Response\n');
      
      if (!hasReply) continue;
      
      const from = t.meta.from;
      if (!from) continue;
      
      const peer = peers[from];
      if (!peer || !peer.clone) continue;
      
      try {
        const threadName = path.basename(t.file, '.md');
        const branchName = `${name}/${threadName}-reply`;
        
        // Push reply to peer's clone
        execSync(`git checkout main 2>/dev/null || git checkout master`, { cwd: peer.clone, stdio: 'pipe' });
        execSync(`git pull --ff-only 2>/dev/null || true`, { cwd: peer.clone, stdio: 'pipe' });
        execSync(`git checkout -b ${branchName} 2>/dev/null || git checkout ${branchName}`, { cwd: peer.clone, stdio: 'pipe' });
        
        const peerThreadDir = path.join(peer.clone, 'threads', 'adhoc');
        if (!fs.existsSync(peerThreadDir)) {
          fs.mkdirSync(peerThreadDir, { recursive: true });
        }
        
        // Copy reply thread
        const replyFileName = `${name}-${threadName}-reply.md`;
        fs.copyFileSync(t.path, path.join(peerThreadDir, replyFileName));
        
        execSync(`git add "threads/adhoc/${replyFileName}"`, { cwd: peer.clone, stdio: 'pipe' });
        execSync(`git commit -m "${name}: reply to ${threadName}"`, { cwd: peer.clone, stdio: 'pipe' });
        execSync(`git push -u origin ${branchName} -f`, { cwd: peer.clone, stdio: 'pipe' });
        execSync(`git checkout main 2>/dev/null || git checkout master`, { cwd: peer.clone, stdio: 'pipe' });
        
        // Archive the inbox thread (move to threads/archived/)
        const archivedDir = path.join(hubPath, 'threads', 'archived');
        if (!fs.existsSync(archivedDir)) {
          fs.mkdirSync(archivedDir, { recursive: true });
        }
        const archivedContent = updateFrontmatter(t.content, { replied: new Date().toISOString() });
        fs.writeFileSync(path.join(archivedDir, t.file), archivedContent);
        fs.unlinkSync(t.path);
        
        logAction(hubPath, 'inbox.reply', { to: from, thread: t.file, branch: branchName, result: 'ok' });
        ok(`Replied to ${from}: ${t.file}`);
        replied++;
      } catch (err) {
        logAction(hubPath, 'inbox.reply', { to: from, thread: t.file, result: 'error', error: err.message });
        fail(`Failed to reply: ${err.message}`);
        execSync(`git checkout main 2>/dev/null || git checkout master 2>/dev/null || true`, { cwd: peer.clone, stdio: 'pipe' });
      }
    }
    
    if (replied === 0) {
      info('No replies to send');
    } else {
      ok(`Sent ${replied} reply(s)`);
    }
    return;
  }
}

// Ensure content has frontmatter with given fields
function ensureFrontmatter(content, meta) {
  const existing = parseFrontmatter(content);
  const merged = { ...existing, ...meta };
  
  // Remove existing frontmatter if present
  const withoutFm = content.replace(/^---\n[\s\S]*?\n---\n*/, '');
  
  // Build new frontmatter
  const fmLines = Object.entries(merged).map(([k, v]) => `${k}: ${v}`).join('\n');
  return `---\n${fmLines}\n---\n\n${withoutFm}`;
}

// Run outbox commands (threads/outbox/ model)
function runOutbox(subCmd, hubPath, name) {
  const outboxDir = path.join(hubPath, 'threads', 'outbox');
  const sentDir = path.join(hubPath, 'threads', 'sent');
  const peersPath = path.join(hubPath, 'state', 'peers.md');
  
  // Ensure directories exist
  if (!fs.existsSync(outboxDir)) {
    fs.mkdirSync(outboxDir, { recursive: true });
  }
  if (!fs.existsSync(sentDir)) {
    fs.mkdirSync(sentDir, { recursive: true });
  }
  
  // Load peers
  let peers = {};
  if (fs.existsSync(peersPath)) {
    const peersContent = fs.readFileSync(peersPath, 'utf8');
    peers = parsePeers(peersContent);
  }
  
  // Scan outbox for threads
  const threads = fs.readdirSync(outboxDir)
    .filter(f => f.endsWith('.md'))
    .map(f => {
      const filePath = path.join(outboxDir, f);
      const content = fs.readFileSync(filePath, 'utf8');
      const meta = parseFrontmatter(content);
      return { file: f, path: filePath, content, meta };
    });
  
  if (subCmd === 'check') {
    if (threads.length === 0) {
      ok('Outbox clear');
      return;
    }
    warn(`${threads.length} pending send(s):`);
    threads.forEach(t => {
      const to = t.meta.to || '(no recipient)';
      console.log(`  → ${to}: ${t.file}`);
    });
    return;
  }
  
  if (subCmd === 'flush') {
    if (threads.length === 0) {
      ok('Outbox clear');
      return;
    }
    
    info(`Flushing ${threads.length} thread(s)...`);
    
    for (const t of threads) {
      const to = t.meta.to;
      if (!to) {
        logAction(hubPath, 'outbox.skip', { thread: t.file, reason: 'no recipient (to: field missing)' });
        warn(`Skipping ${t.file}: no 'to:' in frontmatter`);
        continue;
      }
      
      const peer = peers[to];
      if (!peer) {
        logAction(hubPath, 'outbox.skip', { thread: t.file, to, reason: 'unknown peer' });
        fail(`Unknown peer: ${to}`);
        continue;
      }
      
      if (!peer.clone) {
        logAction(hubPath, 'outbox.skip', { thread: t.file, to, reason: 'no clone path configured' });
        fail(`No clone path for peer: ${to}`);
        continue;
      }
      
      try {
        const threadName = path.basename(t.file, '.md');
        const branchName = `${name}/${threadName}`;
        
        // Actor model: push to PEER's repo (their clone)
        // 1. Ensure peer clone is on main and up to date
        execSync(`git checkout main 2>/dev/null || git checkout master`, { cwd: peer.clone, stdio: 'pipe' });
        execSync(`git pull --ff-only 2>/dev/null || true`, { cwd: peer.clone, stdio: 'pipe' });
        
        // 2. Create branch in peer's clone
        execSync(`git checkout -b ${branchName} 2>/dev/null || git checkout ${branchName}`, { cwd: peer.clone, stdio: 'pipe' });
        
        // 3. Copy thread to peer's threads/adhoc/ (standardized location)
        const peerThreadDir = path.join(peer.clone, 'threads', 'adhoc');
        if (!fs.existsSync(peerThreadDir)) {
          fs.mkdirSync(peerThreadDir, { recursive: true });
        }
        const peerThreadPath = path.join(peerThreadDir, t.file);
        fs.copyFileSync(t.path, peerThreadPath);
        
        // 4. Commit and push
        execSync(`git add "threads/adhoc/${t.file}"`, { cwd: peer.clone, stdio: 'pipe' });
        execSync(`git commit -m "${name}: ${threadName}"`, { cwd: peer.clone, stdio: 'pipe' });
        execSync(`git push -u origin ${branchName} -f`, { cwd: peer.clone, stdio: 'pipe' });
        
        // 5. Return to main
        execSync(`git checkout main 2>/dev/null || git checkout master`, { cwd: peer.clone, stdio: 'pipe' });
        
        // Move to sent/
        const sentPath = path.join(sentDir, t.file);
        const sentContent = updateFrontmatter(t.content, { sent: new Date().toISOString() });
        fs.writeFileSync(sentPath, sentContent);
        fs.unlinkSync(t.path);
        
        logAction(hubPath, 'outbox.send', { to, thread: t.file, branch: branchName, clone: peer.clone, result: 'ok' });
        ok(`Sent to ${to}: ${t.file}`);
      } catch (err) {
        logAction(hubPath, 'outbox.send', { to, thread: t.file, result: 'error', error: err.message });
        fail(`Failed to send ${t.file}: ${err.message}`);
        execSync(`git checkout main 2>/dev/null || true`, { cwd: hubPath, stdio: 'pipe' });
      }
    }
    
    ok('Outbox flush complete');
  }
}

// Commit command — agent requests, cn executes
function runCommit(hubPath, name, message) {
  // Check for uncommitted changes
  const status = execSync('git status --porcelain', { cwd: hubPath, encoding: 'utf8' }).trim();
  
  if (!status) {
    info('Nothing to commit');
    return;
  }
  
  // Default message if none provided
  if (!message || message.trim() === '') {
    message = `${name}: auto-commit ${new Date().toISOString().slice(0, 10)}`;
  }
  
  try {
    // Stage all changes
    execSync('git add -A', { cwd: hubPath, stdio: 'pipe' });
    
    // Commit
    execSync(`git commit -m "${message.replace(/"/g, '\\"')}"`, { cwd: hubPath, stdio: 'pipe' });
    
    logAction(hubPath, 'commit', { message, result: 'ok' });
    ok(`Committed: ${message}`);
  } catch (err) {
    logAction(hubPath, 'commit', { message, result: 'error', error: err.message });
    fail(`Commit failed: ${err.message}`);
  }
}

// Push command — push to origin
function runPush(hubPath, name) {
  try {
    // Get current branch
    const branch = execSync('git branch --show-current', { cwd: hubPath, encoding: 'utf8' }).trim();
    
    // Push
    execSync(`git push origin ${branch}`, { cwd: hubPath, stdio: 'pipe' });
    
    logAction(hubPath, 'push', { branch, result: 'ok' });
    ok(`Pushed to origin/${branch}`);
  } catch (err) {
    logAction(hubPath, 'push', { result: 'error', error: err.message });
    fail(`Push failed: ${err.message}`);
  }
}

// Parse YAML frontmatter
function parseFrontmatter(content) {
  const match = content.match(/^---\n([\s\S]*?)\n---/);
  if (!match) return {};
  const yaml = match[1];
  const meta = {};
  yaml.split('\n').forEach(line => {
    const [key, ...rest] = line.split(':');
    if (key && rest.length) {
      meta[key.trim().toLowerCase()] = rest.join(':').trim();
    }
  });
  return meta;
}

// Update frontmatter field
function updateFrontmatter(content, updates) {
  const match = content.match(/^---\n([\s\S]*?)\n---/);
  if (!match) {
    // No frontmatter, add it
    const lines = Object.entries(updates).map(([k, v]) => `${k}: ${v}`).join('\n');
    return `---\n${lines}\n---\n\n${content}`;
  }
  let yaml = match[1];
  for (const [key, val] of Object.entries(updates)) {
    const regex = new RegExp(`^${key}:.*$`, 'm');
    if (regex.test(yaml)) {
      yaml = yaml.replace(regex, `${key}: ${val}`);
    } else {
      yaml += `\n${key}: ${val}`;
    }
  }
  return content.replace(/^---\n[\s\S]*?\n---/, `---\n${yaml}\n---`);
}

// Parse outbox.md table
function parseOutbox(content) {
  const items = [];
  const lines = content.split('\n');
  let inTable = false;
  
  for (const line of lines) {
    if (line.startsWith('| To')) {
      inTable = true;
      continue;
    }
    if (line.startsWith('|--')) continue;
    if (!inTable || !line.startsWith('|')) continue;
    
    const cols = line.split('|').map(c => c.trim()).filter(c => c);
    if (cols.length >= 3) {
      items.push({
        to: cols[0],
        thread: cols[1],
        status: cols[2] || 'pending',
        sent: cols[3] || null
      });
    }
  }
  return items;
}

// Write outbox.md
function writeOutbox(outboxPath, items) {
  let content = `# Outbox

Agent writes pending sends here. cn reads and executes.

| To | Thread | Status | Sent |
|----|--------|--------|------|
`;
  for (const item of items) {
    content += `| ${item.to} | ${item.thread} | ${item.status} | ${item.sent || '—'} |\n`;
  }
  fs.writeFileSync(outboxPath, content);
}

// Parse peers.md
function parsePeers(content) {
  const peers = {};
  // Match each peer block
  const blocks = content.split(/(?=- name:)/);
  for (const block of blocks) {
    const nameMatch = block.match(/- name:\s*(\S+)/);
    if (!nameMatch) continue;
    const name = nameMatch[1];
    const hubMatch = block.match(/hub:\s*(\S+)/);
    const cloneMatch = block.match(/clone:\s*(\S+)/);
    peers[name] = { 
      name, 
      hub: hubMatch ? hubMatch[1] : null,
      clone: cloneMatch ? cloneMatch[1] : null
    };
  }
  return peers;
}

// Doctor command
function doctor(hubPath) {
  console.log(`cn v${VERSION}`);
  info(`Checking health...`);
  console.log('');
  
  let checks = [];
  let warnings = [];
  
  // Git
  try {
    const gitVersion = execSync('git --version', { encoding: 'utf8' }).trim();
    checks.push({ name: 'git', ok: true, val: gitVersion.replace('git version ', '') });
  } catch {
    checks.push({ name: 'git', ok: false, val: 'not installed' });
  }
  
  // Git config
  try {
    const userName = execSync('git config user.name', { encoding: 'utf8' }).trim();
    checks.push({ name: 'git user.name', ok: true, val: userName });
  } catch {
    checks.push({ name: 'git user.name', ok: false, val: 'not set' });
  }
  
  try {
    const userEmail = execSync('git config user.email', { encoding: 'utf8' }).trim();
    checks.push({ name: 'git user.email', ok: true, val: userEmail });
  } catch {
    checks.push({ name: 'git user.email', ok: false, val: 'not set' });
  }
  
  // Hub directory
  checks.push({ name: 'hub directory', ok: fs.existsSync(hubPath), val: fs.existsSync(hubPath) ? 'exists' : 'not found' });
  
  // .cn/config.json
  const configPath = path.join(hubPath, '.cn', 'config.json');
  checks.push({ name: '.cn/config.json', ok: fs.existsSync(configPath), val: fs.existsSync(configPath) ? 'exists' : 'missing' });
  
  // spec/SOUL.md
  const soulPath = path.join(hubPath, 'spec', 'SOUL.md');
  if (fs.existsSync(soulPath)) {
    checks.push({ name: 'spec/SOUL.md', ok: true, val: 'exists' });
  } else {
    warnings.push({ name: 'spec/SOUL.md', val: 'missing (optional)' });
  }
  
  // state/peers.md
  const peersPath = path.join(hubPath, 'state', 'peers.md');
  if (fs.existsSync(peersPath)) {
    const content = fs.readFileSync(peersPath, 'utf8');
    const peerCount = (content.match(/- name:/g) || []).length;
    checks.push({ name: 'state/peers.md', ok: true, val: `${peerCount} peer(s)` });
  } else {
    checks.push({ name: 'state/peers.md', ok: false, val: 'missing' });
  }
  
  // origin remote
  try {
    execSync('git remote get-url origin', { cwd: hubPath, encoding: 'utf8', stdio: ['pipe', 'pipe', 'pipe'] });
    checks.push({ name: 'origin remote', ok: true, val: 'configured' });
  } catch {
    checks.push({ name: 'origin remote', ok: false, val: 'not configured' });
  }
  
  // inbox status
  try {
    const result = execSync(`node ${path.join(__dirname, '..', 'dist', 'inbox.js')} check ${hubPath} ${deriveName(hubPath)} 2>&1`, { encoding: 'utf8' });
    const inboundMatch = result.match(/(\d+) inbound/);
    if (inboundMatch) {
      const count = parseInt(inboundMatch[1]);
      if (count > 0) {
        warnings.push({ name: 'inbox', val: `${count} pending` });
      } else {
        checks.push({ name: 'inbox', ok: true, val: 'clear' });
      }
    } else if (result.includes('All clear')) {
      checks.push({ name: 'inbox', ok: true, val: 'clear' });
    }
  } catch {
    warnings.push({ name: 'inbox', val: 'check failed' });
  }
  
  // Print checks
  const width = 22;
  checks.forEach(({ name, ok: isOk, val }) => {
    const dots = '.'.repeat(Math.max(1, width - name.length));
    const status = isOk 
      ? `${c.green}✓ ${val}${c.reset}`
      : `${c.red}✗ ${val}${c.reset}`;
    console.log(`${name}${dots} ${status}`);
  });
  
  // Print warnings
  warnings.forEach(({ name, val }) => {
    const dots = '.'.repeat(Math.max(1, width - name.length));
    console.log(`${name}${dots} ${c.yellow}⚠ ${val}${c.reset}`);
  });
  
  console.log('');
  const fails = checks.filter(c => !c.ok).length;
  const warns = warnings.length;
  
  if (fails === 0) {
    ok('All critical checks passed.');
  } else {
    fail(`${fails} issue(s) found.`);
  }
  
  console.log(`${c.dim}[status] ok=${checks.filter(c=>c.ok).length} warn=${warns} fail=${fails} version=${VERSION}${c.reset}`);
  process.exit(fails > 0 ? 1 : 0);
}

// Status command
function status(hubPath, name) {
  info(`cn hub: ${name}`);
  console.log('');
  console.log(`hub..................... ${c.green}✓${c.reset}`);
  console.log(`name.................... ${c.green}✓ ${name}${c.reset}`);
  console.log(`path.................... ${c.green}✓ ${hubPath}${c.reset}`);
  console.log('');
  console.log(`${c.dim}[status] ok version=${VERSION}${c.reset}`);
}

// Main
const args = process.argv.slice(2);
if (args.length === 0 || args[0] === '--help' || args[0] === '-h') {
  console.log(HELP);
  process.exit(0);
}

if (args[0] === '--version' || args[0] === '-V') {
  console.log(`cn ${VERSION}`);
  process.exit(0);
}

const command = expandAlias(args[0]);
const subArgs = args.slice(1);

// Commands that don't need hub
if (command === 'init') {
  warn('cn init not yet implemented');
  process.exit(1);
}

if (command === 'update') {
  // Check if already on latest
  try {
    const latest = execSync('npm view cnagent version', { encoding: 'utf8' }).trim();
    if (VERSION === latest) {
      ok(`Already up to date (v${VERSION})`);
      // Still write runtime.md if in a hub
      writeRuntimeMd(findHubPath(), latest);
      process.exit(0);
    }
    info(`Updating cnagent v${VERSION} → v${latest}...`);
    execSync('npm install -g cnagent@latest', { stdio: 'inherit' });
    ok(`Updated to v${latest}`);
    // Write runtime.md if in a hub
    writeRuntimeMd(findHubPath(), latest);
  } catch (e) {
    fail('Update failed. Try: npm install -g cnagent@latest');
    process.exit(1);
  }
  process.exit(0);
}

// Write state/runtime.md after update
function writeRuntimeMd(hubPath, cnVersion) {
  if (!hubPath) return; // Not in a hub, skip
  
  const runtimePath = path.join(hubPath, 'state', 'runtime.md');
  const stateDir = path.join(hubPath, 'state');
  
  // Ensure state/ exists
  if (!fs.existsSync(stateDir)) {
    fs.mkdirSync(stateDir, { recursive: true });
  }
  
  // Get template version and commit
  let templateVersion = 'unknown';
  let cnCommit = 'unknown';
  const cnDir = path.join(__dirname, '..');
  try {
    const pkgPath = path.join(cnDir, 'package.json');
    if (fs.existsSync(pkgPath)) {
      const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));
      templateVersion = pkg.version || 'unknown';
    }
    cnCommit = execSync('git rev-parse --short HEAD 2>/dev/null', { 
      encoding: 'utf8', 
      cwd: cnDir 
    }).trim() || 'unknown';
  } catch {}
  
  // Gather runtime info (agent-relevant only)
  const hubName = deriveName(hubPath);
  
  // Hub commit hash
  let hubCommit = 'unknown';
  try {
    hubCommit = execSync('git rev-parse --short HEAD 2>/dev/null', { 
      encoding: 'utf8', 
      cwd: hubPath 
    }).trim() || 'unknown';
  } catch {}
  
  // OpenClaw version
  let openclawVersion = 'not installed';
  try {
    openclawVersion = execSync('openclaw --version 2>/dev/null', { encoding: 'utf8' }).trim();
  } catch {}
  
  let peerCount = 0;
  try {
    const peersPath = path.join(hubPath, 'state', 'peers.md');
    if (fs.existsSync(peersPath)) {
      const content = fs.readFileSync(peersPath, 'utf8');
      peerCount = (content.match(/- name:/g) || []).length;
    }
  } catch {}

  const content = `# Runtime State

Auto-generated by \`cn update\`. Do not edit manually.

\`\`\`yaml
session_start: ${new Date().toISOString()}
cn_version: ${cnVersion}
cn_commit: ${cnCommit}
template_version: ${templateVersion}
openclaw_version: ${openclawVersion}
hub_name: ${hubName}
hub_commit: ${hubCommit}
peer_count: ${peerCount}
\`\`\`
`;

  fs.writeFileSync(runtimePath, content);
  info(`Wrote ${runtimePath}`);
}

// Find hub
const hubPath = findHubPath();
if (!hubPath) {
  fail('Not in a cn hub.');
  console.log('');
  console.log('Either:');
  console.log(`  1) ${cmd('cd')} into an existing hub (cn-sigma, cn-pi, etc.)`);
  console.log(`  2) ${cmd('cn init <name>')} to create a new one`);
  process.exit(1);
}

const name = deriveName(hubPath);

switch (command) {
  case 'status':
    status(hubPath, name);
    break;
    
  case 'doctor':
    doctor(hubPath);
    break;
    
  case 'inbox':
    const inboxSubCmd = subArgs[0] || 'check';
    if (!['check', 'process', 'flush'].includes(inboxSubCmd)) {
      fail(`Unknown inbox command: ${inboxSubCmd}`);
      process.exit(1);
    }
    runInbox(inboxSubCmd, hubPath, name);
    break;
    
  case 'outbox':
    const outboxSubCmd = subArgs[0] || 'check';
    if (!['check', 'flush'].includes(outboxSubCmd)) {
      fail(`Unknown outbox command: ${outboxSubCmd}`);
      process.exit(1);
    }
    runOutbox(outboxSubCmd, hubPath, name);
    break;
    
  case 'sync':
    info('Running sync...');
    runInbox('check', hubPath, name);
    runInbox('process', hubPath, name);
    runInbox('flush', hubPath, name);
    runOutbox('flush', hubPath, name);
    ok('Sync complete');
    break;
    
  case 'commit':
    runCommit(hubPath, name, subArgs.join(' '));
    break;
    
  case 'push':
    runPush(hubPath, name);
    break;
    
  case 'save':
    // Convenience: commit + push
    runCommit(hubPath, name, subArgs.join(' ') || `${name}: save ${new Date().toISOString().slice(0, 16)}`);
    runPush(hubPath, name);
    break;
    
  default:
    fail(`Unknown command: ${command}`);
    console.log(`Run ${cmd('cn --help')} for usage.`);
    process.exit(1);
}
