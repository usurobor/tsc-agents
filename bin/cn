#!/usr/bin/env node

/**
 * cn - Coherent Network agent CLI
 * 
 * This is a thin wrapper that routes to the appropriate tool.
 * OCaml source in tools/src/cn/, bundled JS in dist/cn.js
 */

const { execSync, spawn } = require('child_process');
const path = require('path');
const fs = require('fs');

const VERSION = '2.0.7';

// Colors (respects NO_COLOR)
const noColor = process.env.NO_COLOR !== undefined;
const c = {
  reset: noColor ? '' : '\x1b[0m',
  green: noColor ? '' : '\x1b[32m',
  red: noColor ? '' : '\x1b[31m',
  yellow: noColor ? '' : '\x1b[33m',
  cyan: noColor ? '' : '\x1b[36m',
  magenta: noColor ? '' : '\x1b[35m',
  dim: noColor ? '' : '\x1b[2m',
};

const ok = (msg) => console.log(`${c.green}✓ ${msg}${c.reset}`);
const fail = (msg) => console.log(`${c.red}✗ ${msg}${c.reset}`);
const info = (msg) => console.log(`${c.cyan}${msg}${c.reset}`);
const warn = (msg) => console.log(`${c.yellow}⚠ ${msg}${c.reset}`);
const cmd = (msg) => `${c.magenta}${msg}${c.reset}`;

const HELP = `cn - Coherent Network agent CLI

Usage: cn <command> [options]

Commands:
  init [name]         Create new hub
  status              Show hub state
  inbox               Manage inbound messages
    check             List inbound branches
    process           Materialize as threads
    flush             Execute decisions
  outbox              Manage outbound messages
    check             List pending sends
    flush             Push branches to peers
  sync                Run inbox check + outbox flush
  peer                Manage peers
  doctor              Check system health
  update              Update cn to latest version

Aliases:
  i = inbox, s = status, d = doctor

Flags:
  --help, -h          Show help
  --version, -V       Show version

Examples:
  cn init sigma       Create hub named 'sigma'
  cn inbox check      List inbound branches
  cn doctor           Check system health
`;

// Expand aliases
const aliases = { i: 'inbox', o: 'outbox', s: 'status', d: 'doctor', p: 'peer', t: 'thread' };
const expandAlias = (cmd) => aliases[cmd] || cmd;

// Find hub path
function findHubPath() {
  let dir = process.cwd();
  while (dir !== '/') {
    if (fs.existsSync(path.join(dir, '.cn', 'config.json'))) {
      return dir;
    }
    // Also check for cn-* pattern with state/peers.md
    if (fs.existsSync(path.join(dir, 'state', 'peers.md'))) {
      return dir;
    }
    dir = path.dirname(dir);
  }
  return null;
}

// Derive name from path
function deriveName(hubPath) {
  const base = path.basename(hubPath);
  return base.startsWith('cn-') ? base.slice(3) : base;
}

// Append-only action log
function logAction(hubPath, action, details = {}) {
  const logsDir = path.join(hubPath, 'logs');
  if (!fs.existsSync(logsDir)) {
    fs.mkdirSync(logsDir, { recursive: true });
  }
  const entry = {
    ts: new Date().toISOString(),
    action,
    ...details
  };
  fs.appendFileSync(
    path.join(logsDir, 'cn.log'),
    JSON.stringify(entry) + '\n'
  );
}

// Run inbox tool
function runInbox(subCmd, hubPath, name) {
  const inboxJs = path.join(__dirname, '..', 'dist', 'inbox.js');
  if (!fs.existsSync(inboxJs)) {
    fail('inbox.js not found. Run from cn-agent directory or install globally.');
    process.exit(1);
  }
  const args = [inboxJs, subCmd, hubPath, name];
  const result = spawn('node', args, { stdio: 'inherit' });
  result.on('close', (code) => process.exit(code));
}

// Run outbox commands
function runOutbox(subCmd, hubPath, name) {
  const outboxPath = path.join(hubPath, 'state', 'outbox.md');
  const peersPath = path.join(hubPath, 'state', 'peers.md');
  
  if (subCmd === 'check') {
    // List pending outbox items
    if (!fs.existsSync(outboxPath)) {
      info('Outbox empty (no state/outbox.md)');
      return;
    }
    const content = fs.readFileSync(outboxPath, 'utf8');
    const pending = parseOutbox(content).filter(item => item.status === 'pending');
    if (pending.length === 0) {
      ok('Outbox clear');
    } else {
      warn(`${pending.length} pending send(s):`);
      pending.forEach(item => {
        console.log(`  → ${item.to}: ${item.thread}`);
      });
    }
    return;
  }
  
  if (subCmd === 'flush') {
    // Execute pending sends
    if (!fs.existsSync(outboxPath)) {
      info('Outbox empty');
      return;
    }
    
    // Load peers
    let peers = {};
    if (fs.existsSync(peersPath)) {
      const peersContent = fs.readFileSync(peersPath, 'utf8');
      peers = parsePeers(peersContent);
    }
    
    const content = fs.readFileSync(outboxPath, 'utf8');
    const items = parseOutbox(content);
    const pending = items.filter(item => item.status === 'pending');
    
    if (pending.length === 0) {
      ok('Outbox clear');
      return;
    }
    
    info(`Flushing ${pending.length} item(s)...`);
    
    for (const item of pending) {
      const peer = peers[item.to];
      if (!peer) {
        fail(`Unknown peer: ${item.to}`);
        item.status = 'error';
        item.error = 'unknown peer';
        continue;
      }
      
      try {
        // Create branch name from thread
        const threadName = path.basename(item.thread, '.md');
        const branchName = `${name}/${threadName}`;
        
        // Check if thread file exists
        const threadPath = path.join(hubPath, item.thread);
        if (!fs.existsSync(threadPath)) {
          fail(`Thread not found: ${item.thread}`);
          item.status = 'error';
          item.error = 'thread not found';
          continue;
        }
        
        // Create branch, add thread, push to peer
        execSync(`git checkout -b ${branchName} 2>/dev/null || git checkout ${branchName}`, { cwd: hubPath, stdio: 'pipe' });
        execSync(`git add ${item.thread}`, { cwd: hubPath, stdio: 'pipe' });
        execSync(`git commit -m "send: ${threadName}" --allow-empty`, { cwd: hubPath, stdio: 'pipe' });
        execSync(`git push ${peer.remote} ${branchName} -f`, { cwd: hubPath, stdio: 'pipe' });
        execSync(`git checkout main`, { cwd: hubPath, stdio: 'pipe' });
        
        item.status = 'sent';
        item.sent = new Date().toISOString();
        logAction(hubPath, 'outbox.send', { to: item.to, thread: item.thread, branch: branchName, remote: peer.remote, result: 'ok' });
        ok(`Sent to ${item.to}: ${item.thread}`);
      } catch (err) {
        logAction(hubPath, 'outbox.send', { to: item.to, thread: item.thread, result: 'error', error: err.message });
        fail(`Failed to send to ${item.to}: ${err.message}`);
        item.status = 'error';
        item.error = err.message;
        execSync(`git checkout main 2>/dev/null || true`, { cwd: hubPath, stdio: 'pipe' });
      }
    }
    
    // Write updated outbox
    writeOutbox(outboxPath, items);
    ok('Outbox flush complete');
  }
}

// Parse outbox.md table
function parseOutbox(content) {
  const items = [];
  const lines = content.split('\n');
  let inTable = false;
  
  for (const line of lines) {
    if (line.startsWith('| To')) {
      inTable = true;
      continue;
    }
    if (line.startsWith('|--')) continue;
    if (!inTable || !line.startsWith('|')) continue;
    
    const cols = line.split('|').map(c => c.trim()).filter(c => c);
    if (cols.length >= 3) {
      items.push({
        to: cols[0],
        thread: cols[1],
        status: cols[2] || 'pending',
        sent: cols[3] || null
      });
    }
  }
  return items;
}

// Write outbox.md
function writeOutbox(outboxPath, items) {
  let content = `# Outbox

Agent writes pending sends here. cn reads and executes.

| To | Thread | Status | Sent |
|----|--------|--------|------|
`;
  for (const item of items) {
    content += `| ${item.to} | ${item.thread} | ${item.status} | ${item.sent || '—'} |\n`;
  }
  fs.writeFileSync(outboxPath, content);
}

// Parse peers.md
function parsePeers(content) {
  const peers = {};
  const matches = content.matchAll(/- name:\s*(\w+)[\s\S]*?remote:\s*(\S+)/g);
  for (const match of matches) {
    peers[match[1]] = { name: match[1], remote: match[2] };
  }
  return peers;
}

// Doctor command
function doctor(hubPath) {
  console.log(`cn v${VERSION}`);
  info(`Checking health...`);
  console.log('');
  
  let checks = [];
  let warnings = [];
  
  // Git
  try {
    const gitVersion = execSync('git --version', { encoding: 'utf8' }).trim();
    checks.push({ name: 'git', ok: true, val: gitVersion.replace('git version ', '') });
  } catch {
    checks.push({ name: 'git', ok: false, val: 'not installed' });
  }
  
  // Git config
  try {
    const userName = execSync('git config user.name', { encoding: 'utf8' }).trim();
    checks.push({ name: 'git user.name', ok: true, val: userName });
  } catch {
    checks.push({ name: 'git user.name', ok: false, val: 'not set' });
  }
  
  try {
    const userEmail = execSync('git config user.email', { encoding: 'utf8' }).trim();
    checks.push({ name: 'git user.email', ok: true, val: userEmail });
  } catch {
    checks.push({ name: 'git user.email', ok: false, val: 'not set' });
  }
  
  // Hub directory
  checks.push({ name: 'hub directory', ok: fs.existsSync(hubPath), val: fs.existsSync(hubPath) ? 'exists' : 'not found' });
  
  // .cn/config.json
  const configPath = path.join(hubPath, '.cn', 'config.json');
  checks.push({ name: '.cn/config.json', ok: fs.existsSync(configPath), val: fs.existsSync(configPath) ? 'exists' : 'missing' });
  
  // spec/SOUL.md
  const soulPath = path.join(hubPath, 'spec', 'SOUL.md');
  if (fs.existsSync(soulPath)) {
    checks.push({ name: 'spec/SOUL.md', ok: true, val: 'exists' });
  } else {
    warnings.push({ name: 'spec/SOUL.md', val: 'missing (optional)' });
  }
  
  // state/peers.md
  const peersPath = path.join(hubPath, 'state', 'peers.md');
  if (fs.existsSync(peersPath)) {
    const content = fs.readFileSync(peersPath, 'utf8');
    const peerCount = (content.match(/- name:/g) || []).length;
    checks.push({ name: 'state/peers.md', ok: true, val: `${peerCount} peer(s)` });
  } else {
    checks.push({ name: 'state/peers.md', ok: false, val: 'missing' });
  }
  
  // origin remote
  try {
    execSync('git remote get-url origin', { cwd: hubPath, encoding: 'utf8', stdio: ['pipe', 'pipe', 'pipe'] });
    checks.push({ name: 'origin remote', ok: true, val: 'configured' });
  } catch {
    checks.push({ name: 'origin remote', ok: false, val: 'not configured' });
  }
  
  // inbox status
  try {
    const result = execSync(`node ${path.join(__dirname, '..', 'dist', 'inbox.js')} check ${hubPath} ${deriveName(hubPath)} 2>&1`, { encoding: 'utf8' });
    const inboundMatch = result.match(/(\d+) inbound/);
    if (inboundMatch) {
      const count = parseInt(inboundMatch[1]);
      if (count > 0) {
        warnings.push({ name: 'inbox', val: `${count} pending` });
      } else {
        checks.push({ name: 'inbox', ok: true, val: 'clear' });
      }
    } else if (result.includes('All clear')) {
      checks.push({ name: 'inbox', ok: true, val: 'clear' });
    }
  } catch {
    warnings.push({ name: 'inbox', val: 'check failed' });
  }
  
  // Print checks
  const width = 22;
  checks.forEach(({ name, ok: isOk, val }) => {
    const dots = '.'.repeat(Math.max(1, width - name.length));
    const status = isOk 
      ? `${c.green}✓ ${val}${c.reset}`
      : `${c.red}✗ ${val}${c.reset}`;
    console.log(`${name}${dots} ${status}`);
  });
  
  // Print warnings
  warnings.forEach(({ name, val }) => {
    const dots = '.'.repeat(Math.max(1, width - name.length));
    console.log(`${name}${dots} ${c.yellow}⚠ ${val}${c.reset}`);
  });
  
  console.log('');
  const fails = checks.filter(c => !c.ok).length;
  const warns = warnings.length;
  
  if (fails === 0) {
    ok('All critical checks passed.');
  } else {
    fail(`${fails} issue(s) found.`);
  }
  
  console.log(`${c.dim}[status] ok=${checks.filter(c=>c.ok).length} warn=${warns} fail=${fails} version=${VERSION}${c.reset}`);
  process.exit(fails > 0 ? 1 : 0);
}

// Status command
function status(hubPath, name) {
  info(`cn hub: ${name}`);
  console.log('');
  console.log(`hub..................... ${c.green}✓${c.reset}`);
  console.log(`name.................... ${c.green}✓ ${name}${c.reset}`);
  console.log(`path.................... ${c.green}✓ ${hubPath}${c.reset}`);
  console.log('');
  console.log(`${c.dim}[status] ok version=${VERSION}${c.reset}`);
}

// Main
const args = process.argv.slice(2);
if (args.length === 0 || args[0] === '--help' || args[0] === '-h') {
  console.log(HELP);
  process.exit(0);
}

if (args[0] === '--version' || args[0] === '-V') {
  console.log(`cn ${VERSION}`);
  process.exit(0);
}

const command = expandAlias(args[0]);
const subArgs = args.slice(1);

// Commands that don't need hub
if (command === 'init') {
  warn('cn init not yet implemented');
  process.exit(1);
}

if (command === 'update') {
  // Check if already on latest
  try {
    const latest = execSync('npm view cnagent version', { encoding: 'utf8' }).trim();
    if (VERSION === latest) {
      ok(`Already up to date (v${VERSION})`);
      // Still write runtime.md if in a hub
      writeRuntimeMd(findHubPath(), latest);
      process.exit(0);
    }
    info(`Updating cnagent v${VERSION} → v${latest}...`);
    execSync('npm install -g cnagent@latest', { stdio: 'inherit' });
    ok(`Updated to v${latest}`);
    // Write runtime.md if in a hub
    writeRuntimeMd(findHubPath(), latest);
  } catch (e) {
    fail('Update failed. Try: npm install -g cnagent@latest');
    process.exit(1);
  }
  process.exit(0);
}

// Write state/runtime.md after update
function writeRuntimeMd(hubPath, cnVersion) {
  if (!hubPath) return; // Not in a hub, skip
  
  const runtimePath = path.join(hubPath, 'state', 'runtime.md');
  const stateDir = path.join(hubPath, 'state');
  
  // Ensure state/ exists
  if (!fs.existsSync(stateDir)) {
    fs.mkdirSync(stateDir, { recursive: true });
  }
  
  // Get template version and commit
  let templateVersion = 'unknown';
  let cnCommit = 'unknown';
  const cnDir = path.join(__dirname, '..');
  try {
    const pkgPath = path.join(cnDir, 'package.json');
    if (fs.existsSync(pkgPath)) {
      const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));
      templateVersion = pkg.version || 'unknown';
    }
    cnCommit = execSync('git rev-parse --short HEAD 2>/dev/null', { 
      encoding: 'utf8', 
      cwd: cnDir 
    }).trim() || 'unknown';
  } catch {}
  
  // Gather runtime info (agent-relevant only)
  const hubName = deriveName(hubPath);
  
  // Hub commit hash
  let hubCommit = 'unknown';
  try {
    hubCommit = execSync('git rev-parse --short HEAD 2>/dev/null', { 
      encoding: 'utf8', 
      cwd: hubPath 
    }).trim() || 'unknown';
  } catch {}
  
  // OpenClaw version
  let openclawVersion = 'not installed';
  try {
    openclawVersion = execSync('openclaw --version 2>/dev/null', { encoding: 'utf8' }).trim();
  } catch {}
  
  let peerCount = 0;
  try {
    const peersPath = path.join(hubPath, 'state', 'peers.md');
    if (fs.existsSync(peersPath)) {
      const content = fs.readFileSync(peersPath, 'utf8');
      peerCount = (content.match(/- name:/g) || []).length;
    }
  } catch {}

  const content = `# Runtime State

Auto-generated by \`cn update\`. Do not edit manually.

\`\`\`yaml
session_start: ${new Date().toISOString()}
cn_version: ${cnVersion}
cn_commit: ${cnCommit}
template_version: ${templateVersion}
openclaw_version: ${openclawVersion}
hub_name: ${hubName}
hub_commit: ${hubCommit}
peer_count: ${peerCount}
\`\`\`
`;

  fs.writeFileSync(runtimePath, content);
  info(`Wrote ${runtimePath}`);
}

// Find hub
const hubPath = findHubPath();
if (!hubPath) {
  fail('Not in a cn hub.');
  console.log('');
  console.log('Either:');
  console.log(`  1) ${cmd('cd')} into an existing hub (cn-sigma, cn-pi, etc.)`);
  console.log(`  2) ${cmd('cn init <name>')} to create a new one`);
  process.exit(1);
}

const name = deriveName(hubPath);

switch (command) {
  case 'status':
    status(hubPath, name);
    break;
    
  case 'doctor':
    doctor(hubPath);
    break;
    
  case 'inbox':
    const inboxSubCmd = subArgs[0] || 'check';
    if (!['check', 'process', 'flush'].includes(inboxSubCmd)) {
      fail(`Unknown inbox command: ${inboxSubCmd}`);
      process.exit(1);
    }
    runInbox(inboxSubCmd, hubPath, name);
    break;
    
  case 'outbox':
    const outboxSubCmd = subArgs[0] || 'check';
    if (!['check', 'flush'].includes(outboxSubCmd)) {
      fail(`Unknown outbox command: ${outboxSubCmd}`);
      process.exit(1);
    }
    runOutbox(outboxSubCmd, hubPath, name);
    break;
    
  case 'sync':
    info('Running sync...');
    runInbox('check', hubPath, name);
    runOutbox('flush', hubPath, name);
    ok('Sync complete');
    break;
    
  default:
    fail(`Unknown command: ${command}`);
    console.log(`Run ${cmd('cn --help')} for usage.`);
    process.exit(1);
}
